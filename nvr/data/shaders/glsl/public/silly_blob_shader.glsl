// Shader downloaded from https://www.shadertoy.com/view/MlX3Ws
// written by shadertoy user Craxic
//
// Name: Silly Blob Shader
// Description: Just a simple blob shader. I remember reading about this technique in a DirectX SDK many years ago. I thought it was awesome and I still do!
// This is the cut off point for the specular. 
#define SPECULAR_THRESHOLD 0.5

// This gives the specular its soft edge. Lower = softer
#define SPECULAR_PRE_CLAMP_MULTIPLIER 50.0

// The specular will never be brighter than this.
#define SPECULAR_MULTIPLIER 0.5

// If this gets smaller, the white specular gets 
// bigger.
#define SPECULAR_POWER 5.0

// Amount of reflection at edge of blob
// Simulates fresnel I guess.
#define MAX_REFLECTION 0.95

// Amount of reflection at center of blob. 
// Simulates fresnel I guess.
#define MIN_REFLECTION 0.0

#define REFLECTION_POWER 1.5

// Circles are generated by calculating the 
// distance from the pixel to the center of 
// the circle. This is then normalized to [0-1]
// with 0 being at the EDGE and 1 being at the
// center. Circle fall represents the threshold
// value that defines the boundaries of the goo
// The name just comes from the fact that we're
// making the "heightmap" fall down this many 
// units.
#define CIRCLE_FALL 0.6

// This is the height of each blob. Too much and 
// you'll lose the soft edges.
#define CIRCLE_HEIGHT 37.0
#define CIRCLE_RADIUS (iResolution.x / 10.0)
#define CIRCLE_DISTANCE (iResolution.x / 5.0)
#define CIRCLE_COLOUR_A vec3(1.2, 0.4, 0.2)
#define CIRCLE_COLOUR_B vec3(1.0, 0.7, 0.3)

vec4 sampleOneCircle(vec2 circlePos, vec2 fragPos, vec3 colour)
{
    float circle = distance(fragPos, circlePos);
    circle = circle / CIRCLE_RADIUS;
    circle *= circle;
    circle = max(0.0, min(1.0, 1.0 - circle));
    circle *= circle;
    return vec4(colour, circle);
}

vec2 noise(int xInt, float time)
{
    float t = time;
    float x = float(xInt + 1);
    
    float d = sin(t * x * 0.2852231);
    float r = t * (x * 0.123652);
    
    return vec2(cos(r) * d, sin(r) * d);
}

vec4 sampleOneMovingCircle(int i, vec2 fragPos)
{
    vec2 n = noise(i, iGlobalTime) * CIRCLE_DISTANCE;
    float x = iResolution.x / 2.0 + n.x;
    float y = iResolution.y / 2.0 + n.y;
    vec2 n2 = noise(i * 3, iGlobalTime / 10.0);
    vec3 col = CIRCLE_COLOUR_A + n2.x * (CIRCLE_COLOUR_B - CIRCLE_COLOUR_A);
    return sampleOneCircle(vec2(x, y), fragPos, col);
}

// return[0].r = Red colour of circle.
// return[0].g = Green colour of circle.
// return[0].b = Blue colour of circle.
// return[0].a = Height of circle (0 to 1)
// return[1].xy = fragCoord
// return[1].z = Height of circle (0 to CIRCLE_HEIGHT)
mat4 sampleCircle(vec2 fragCoord)
{
    float circle = 0.0;
    vec4 circleColour = vec4(0.0, 0.0, 0.0, 0.0);
    
    for (int i = 0; i < 10; i++) {
        vec4 c = sampleOneMovingCircle(i, fragCoord);
        circle = circle * (1.0 - c.a) + c.a;
        circleColour += vec4(c.rgb * c.a, c.a);
    }
    circleColour /= circleColour.a;
    
    circle -= CIRCLE_FALL;
    circle /= (1.0 - CIRCLE_FALL);
    circle = sqrt(circle + 0.3) - 0.25;
    circle = clamp(circle, 0.0, 1.0);
    
    mat4 retn;
    retn[0] = vec4(circleColour.rgb, circle);
    retn[1] = vec4(fragCoord, circle * CIRCLE_HEIGHT, 0.0);
    return retn;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    mat4 circle = sampleCircle(fragCoord);
    float circleMask = max(0.0, min(1.0, (circle[1].z)));
    
    vec3 circleTL = sampleCircle(fragCoord + vec2(-0.5, 0.0))[1].xyz;
    vec3 circleTR = sampleCircle(fragCoord + vec2(0.0, 0.0))[1].xyz;
    vec3 circleBL = sampleCircle(fragCoord + vec2(-0.5, -0.5))[1].xyz;
    vec3 circleBR = sampleCircle(fragCoord + vec2(0.0, -0.5))[1].xyz;
    
    vec3 xgrad = (circleTL - circleTR);
    vec3 ygrad = (circleTL - circleBL);
    vec3 normal_bias = vec3(1.0,1.0,1.0);
    vec3 normal = -cross(xgrad * normal_bias, ygrad * normal_bias);
    normal = normalize(normal);
    
    vec3 lightDir = normalize(vec3(cos(iGlobalTime), sin(iGlobalTime), 0.1));
    
    // I wasn't sure how this was done, so Google to the rescue! 
   	// https://en.wikibooks.org/wiki/GLSL_Programming/GLUT/Specular_Highlights
    // I've noticed that sometimes I get black lines here though...
    float specularReflectionRaw;
    if (dot(normal, lightDir) < 0.0) {
        specularReflectionRaw = 0.0;
    } else {
        specularReflectionRaw = pow(dot(reflect(-lightDir, normal), vec3(0.0, 0.0, 1.0)), SPECULAR_POWER);
    }
    float specularReflection = specularReflectionRaw;
    specularReflection -= SPECULAR_THRESHOLD;
    specularReflection *= SPECULAR_PRE_CLAMP_MULTIPLIER;
    specularReflection = clamp(specularReflection, 0.0, 1.0);
    vec4 spec = vec4(1, 1, 1, 0.0) * specularReflection * SPECULAR_MULTIPLIER;

    // Sample the cube map!
    vec4 tex = textureCube(iChannel0, normal);
    
    // Get the colour of the blob as a vec4.
    vec4 col = vec4(circle[0].rgb, 1.0);
    
    // SSS Multiplier. 
    float lighting = dot(lightDir, normal);
    float sss = (lighting * 0.3 + 0.7) * (1.0 - circle[0].a * 0.6);
    
    // k mixes texure and a solid colour
    // If k is 0.0, then the texture is a solid colour.
    float k = MIN_REFLECTION + pow(1.0 - circle[0].a, REFLECTION_POWER) * (MAX_REFLECTION - MIN_REFLECTION);
    float ik = 1.0 - k; // "Inverse" of k, just to save letters!
    col = (tex * k + vec4(ik, ik, ik, ik) * sss) * col;
    
    // Calculate final output
    fragColor = (spec + col) * circleMask;
	fragColor.a = 1.0;
    // fragColor = vec4(h, h, h, 1.0);
    
    // fragColor = vec4(normal, 1.0);
}