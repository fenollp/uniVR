input_stream: "input_frame"

node {
  calculator: "PacketResamplerCalculator"
  input_stream: "DATA:input_frame"
  output_stream: "DATA:throttled_input_frame"
  node_options: {
    [type.googleapis.com/mediapipe.PacketResamplerCalculatorOptions] {
      frame_rate: 4
    }
  }
}

node: {
  calculator: "ImageTransformationCalculator"
  input_stream: "IMAGE_GPU:throttled_input_frame"
  output_stream: "IMAGE_GPU:transformed"
  output_stream: "LETTERBOX_PADDING:letterbox_padding"
  node_options: {
    [type.googleapis.com/mediapipe.ImageTransformationCalculatorOptions] {
      output_width: 128
      output_height: 128
      scale_mode: FIT # preserves aspect, resulting in potential letterboxing
    }
  }
}

node {
  calculator: "TfLiteConverterCalculator"
  input_stream: "IMAGE_GPU:transformed"
  output_stream: "TENSORS_GPU:image_tensors"
}

node {
  calculator: "TfLiteInferenceCalculator"
  input_stream: "TENSORS_GPU:image_tensors"
  output_stream: "TENSORS_GPU:detection_tensors"
  node_options: {
    [type.googleapis.com/mediapipe.TfLiteInferenceCalculatorOptions] {
      model_path: "nvr/models/face_detection_front.tflite"
    }
  }
}

# Generates a single side packet containing a vector of SSD anchors based on
# the specification in the options.
node {
  calculator: "SsdAnchorsCalculator"
  output_side_packet: "anchors"
  node_options: {
    [type.googleapis.com/mediapipe.SsdAnchorsCalculatorOptions] {
      num_layers: 4
      min_scale: 0.1484375
      max_scale: 0.75
      input_size_height: 128
      input_size_width: 128
      anchor_offset_x: 0.5
      anchor_offset_y: 0.5
      strides: 8
      strides: 16
      strides: 16
      strides: 16
      aspect_ratios: 1.0
      fixed_anchor_size: true
    }
  }
}

# Decodes the detection tensors generated by the TensorFlow Lite model, based on
# the SSD anchors and the specification in the options, into a vector of
# detections. Each detection describes a detected object.
node {
  calculator: "TfLiteTensorsToDetectionsCalculator"
  input_stream: "TENSORS_GPU:detection_tensors"
  input_side_packet: "ANCHORS:anchors"
  output_stream: "DETECTIONS:detections"
  node_options: {
    [type.googleapis.com/mediapipe.TfLiteTensorsToDetectionsCalculatorOptions] {
      num_classes: 1
      num_boxes: 896
      num_coords: 16
      box_coord_offset: 0
      keypoint_coord_offset: 4
      num_keypoints: 6
      num_values_per_keypoint: 2
      sigmoid_score: true
      score_clipping_thresh: 100.0
      reverse_output_order: true
      x_scale: 128.0
      y_scale: 128.0
      h_scale: 128.0
      w_scale: 128.0
      min_score_thresh: 0.75
    }
  }
}

# Performs non-max suppression to remove excessive detections.
node {
  calculator: "NonMaxSuppressionCalculator"
  input_stream: "detections"
  output_stream: "filtered_detections"
  node_options: {
    [type.googleapis.com/mediapipe.NonMaxSuppressionCalculatorOptions] {
      min_suppression_threshold: 0.3
      overlap_type: INTERSECTION_OVER_UNION
      algorithm: WEIGHTED
      return_empty_detections: true
    }
  }
}

# Adjusts detection locations (already normalized to [0.f, 1.f]) on the
# letterboxed image (after image transformation with the FIT scale mode) to the
# corresponding locations on the same image with the letterbox removed (the
# input image to the graph before image transformation).
node {
  calculator: "DetectionLetterboxRemovalCalculator"
  input_stream: "DETECTIONS:filtered_detections"
  input_stream: "LETTERBOX_PADDING:letterbox_padding"
  output_stream: "DETECTIONS:heads"
}


node {
  calculator: "ObjectTrackingSubgraph"
  input_stream: "VIDEO:input_frame"
  input_stream: "DETECTIONS:heads"
  output_stream: "DETECTIONS:tracked_heads"
}

node {
  calculator: "RendererSubgraph"
  input_stream: "IMAGE:input_frame"
  input_stream: "DETECTIONS:tracked_heads"
  output_stream: "IMAGE:output_frame"
}

node {
  calculator: "FaceDetectionsToNVRCalculator"
  input_stream: "DETECTIONS:tracked_heads"
  input_side_packet: "nvr"
}

# node {
#   calculator: "LandmarksToRenderDataCalculator"
#   input_stream: "NORM_LANDMARKS:nvr"
#   output_stream: "RENDER_DATA:nvr_render_data"
#   node_options: {
#     [type.googleapis.com/mediapipe.LandmarksToRenderDataCalculatorOptions] {
#       thickness: 4
#     }
#   }
# }


## rendering

node {
  calculator: "OpenCvWindowCalculator"
  input_side_packet: "NAME:window_name"
  input_side_packet: "CLOSED:window_was_closed"
  input_stream: "output_frame"
}
