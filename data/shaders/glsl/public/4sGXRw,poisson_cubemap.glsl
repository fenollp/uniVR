// Shader downloaded from https://www.shadertoy.com/view/4sGXRw
// written by shadertoy user cornusammonis
//
// Name: Poisson Cubemap
// Description: This runs an approximate iterative Poisson solver on a vector field generated by a reaction-diffusion system, then uses the result as a heightmap. Hit spacebar to reset (useful in fullscreen).
/*
	Poisson Cubemap
	
	This shader generates a vector field using a reaction-diffusion system in
	Buffer A, then runs a Poisson solver on the vector field to generate a 
    heightmap in Buffer B. The heightmap is raymarched as a displacement on
	the surface of a sphere.

	Rendering is partly based on iq's Sculpture III:
	https://www.shadertoy.com/view/XtjSDK
	
*/

// iq's cubemap function
vec3 texCube( sampler2D sam, in vec3 d, in float s)
{
    vec3 colx = texture2D( sam, fract(0.5 + s*d.yz/d.x)).xyz;
    vec3 coly = texture2D( sam, fract(0.5 + s*d.zx/d.y)).xyz;
    vec3 colz = texture2D( sam, fract(0.5 + s*d.xy/d.z)).xyz;
    
    vec3 n = d*d;
    
    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);
}

vec2 map( vec3 q )
{
    float td = 0.03 * texCube( iChannel0, q, 0.25).x;
	return vec2(length(q - vec3(0.0, 0.22, 0.0)) - 2.25  + td, td);
}

vec2 intersect( in vec3 ro, in vec3 rd )
{
	const float maxd = 6.0;

	float precis = 0.05;
    vec2 h = vec2(1.0);
    float t = 1.0;
    float td = 0.0;
    for( int i=0; i<50; i++ )
    {
        if( (h.x<precis) || (t>maxd) ) break;
	    h = map( ro+rd*t );
        t += 0.5 * h.x;
        td = h.y;
    }

    if( t>maxd ) t=-1.0;
	return vec2(t, td);
}

vec3 calcNormal( in vec3 pos )
{
    vec3 eps = vec3(0.005,0.0,0.0);
	return normalize( vec3(
           map(pos+eps.xyy).x - map(pos-eps.xyy).x,
           map(pos+eps.yxy).x - map(pos-eps.yxy).x,
           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;
	vec2 q = fragCoord/iResolution.xy;

    vec2 m = vec2(0.5);
	if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;

    
    //-----------------------------------------------------
    // camera
    //-----------------------------------------------------
	
	float an = 1.1 + 0.05*(iGlobalTime-10.0) - 7.0*m.x;

	vec3 ro = vec3(4.5*sin(an),1.0,4.5*cos(an));
    vec3 ta = vec3(0.0,0.2,0.0);
    // camera matrix
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
	// create view ray
	vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );


    //-----------------------------------------------------
	// render
    //-----------------------------------------------------
    
	vec3 col = vec3(0.1)*clamp(1.0-length(q-0.5),0.0,1.0);

	// raymarch
    vec2 h = intersect(ro,rd);
    float occ = 0.5 - h.y;
    float t = h.x;

    if( t>0.0 )
    {
        vec3 pos = ro + t*rd;
        vec3 nor = calcNormal(pos);

		col = vec3(0.05);
        
        col *= mix(0.0, 1.0, occ);
        col *= mix(0.0, 3.0, occ*occ*occ );
        
        // lighting
        float fre = 4.0 * clamp( 1.0 + dot(rd,nor), 0.0, 1.0 );
        float spe = 0.4 * pow(max( dot(-rd,nor),0.0),8.0);
        col = col * fre + spe;
    }

	col = pow(col,vec3(0.4));
    
    fragColor = vec4( col, 1.0 );
}